From 1bfcfcbab0efe06771483ca15fb391be1106d21e Mon Sep 17 00:00:00 2001
From: Idderf Salem <85516773+slubbles@users.noreply.github.com>
Date: Sat, 24 Jan 2026 07:25:41 +0000
Subject: [PATCH 2/2] Fix OAuth users created without email

- Update signIn callback to capture email from OAuth profile
- Add email verification for OAuth providers
- Fixes checkout 400 error for Google OAuth users
- Prevents future users from being created without email
---
 VERCEL_ENV_SETUP.md            | 80 +++++++++++++++++++++++++++++
 check-user.mjs                 | 56 +++++++++++++++++++++
 components/pricing-cards.tsx   | 41 ++++++---------
 lib/auth.ts                    | 92 +++++++++++++++-------------------
 scripts/fix-missing-emails.mjs |  0
 5 files changed, 191 insertions(+), 78 deletions(-)
 create mode 100644 check-user.mjs
 create mode 100644 scripts/fix-missing-emails.mjs

diff --git a/VERCEL_ENV_SETUP.md b/VERCEL_ENV_SETUP.md
index e69de29..7b0f9db 100644
--- a/VERCEL_ENV_SETUP.md
+++ b/VERCEL_ENV_SETUP.md
@@ -0,0 +1,80 @@
+# Vercel Environment Variables Setup for Checkout Fix
+
+## üö® CRITICAL: Add These to Vercel
+
+The checkout 401 error is caused by missing NextAuth v5 environment variables in production.
+
+### Required Variables in Vercel Dashboard
+
+Go to: **Vercel Dashboard ‚Üí Your Project ‚Üí Settings ‚Üí Environment Variables**
+
+Add these variables (select **Production**, **Preview**, and **Development** environments):
+
+```env
+# NextAuth v5 Configuration (REQUIRED)
+AUTH_SECRET=your-secret-here-minimum-32-characters
+AUTH_URL=https://www.postcontent.io
+
+# Keep existing variables or add if missing:
+NEXTAUTH_SECRET=your-secret-here-minimum-32-characters
+NEXTAUTH_URL=https://www.postcontent.io
+```
+
+### Generate AUTH_SECRET
+
+Run this command to generate a secure secret:
+
+```bash
+openssl rand -base64 32
+```
+
+**Important:** Use the SAME value for both `AUTH_SECRET` and `NEXTAUTH_SECRET` for backward compatibility.
+
+### Quick Setup via Vercel CLI
+
+If you have Vercel CLI installed:
+
+```bash
+# Generate a secret
+SECRET=$(openssl rand -base64 32)
+
+# Add to Vercel
+vercel env add AUTH_SECRET production
+# Paste the $SECRET value when prompted
+
+vercel env add AUTH_URL production  
+# Enter: https://www.postcontent.io
+```
+
+### After Adding Variables
+
+1. **Redeploy** the application (or trigger a new deployment)
+2. Variables will be available on next deployment
+3. Test the checkout flow again
+
+### Verify in Logs
+
+After deployment, check Vercel logs for the checkout endpoint. You should see:
+
+```
+[Checkout] Session check: {
+  hasSession: true,
+  hasUser: true,
+  hasEmail: true,
+  email: 'user@example.com',
+  hasCookies: true,
+  hasSessionToken: true,
+  authSecret: true
+}
+```
+
+If `authSecret: false`, the environment variable is not set correctly.
+
+### Troubleshooting
+
+If checkout still fails after adding variables:
+
+1. **Clear Vercel cache**: `vercel --prod --force`
+2. **Check environment scope**: Ensure variables are set for "Production" environment
+3. **Verify deployment**: Check that the latest code is deployed (commit 3af1579 or later)
+4. **Check user login**: User must be logged in before attempting checkout
diff --git a/check-user.mjs b/check-user.mjs
new file mode 100644
index 0000000..26b61e7
--- /dev/null
+++ b/check-user.mjs
@@ -0,0 +1,56 @@
+import { PrismaClient } from '@prisma/client'
+
+const prisma = new PrismaClient()
+
+async function checkUser() {
+  try {
+    // Get all users to see what we have
+    const users = await prisma.user.findMany({
+      select: {
+        id: true,
+        email: true,
+        name: true,
+        emailVerified: true,
+        createdAt: true,
+        accounts: {
+          select: {
+            provider: true
+          }
+        }
+      },
+      orderBy: {
+        createdAt: 'desc'
+      },
+      take: 5
+    })
+    
+    console.log('\nüìä Recent Users in Database:\n')
+    users.forEach((user, i) => {
+      console.log(`${i + 1}. ID: ${user.id}`)
+      console.log(`   Email: ${user.email || '‚ùå NO EMAIL'}`)
+      console.log(`   Name: ${user.name || 'N/A'}`)
+      console.log(`   Email Verified: ${user.emailVerified ? '‚úÖ' : '‚ùå'}`)
+      console.log(`   Auth: ${user.accounts.map(a => a.provider).join(', ') || 'credentials'}`)
+      console.log(`   Created: ${user.createdAt}`)
+      console.log('')
+    })
+    
+    // Check for users without email
+    const noEmailCount = await prisma.user.count({
+      where: {
+        email: null
+      }
+    })
+    
+    if (noEmailCount > 0) {
+      console.log(`‚ö†Ô∏è  WARNING: ${noEmailCount} users without email in database!`)
+    }
+    
+  } catch (error) {
+    console.error('‚ùå Error:', error)
+  } finally {
+    await prisma.$disconnect()
+  }
+}
+
+checkUser()
diff --git a/components/pricing-cards.tsx b/components/pricing-cards.tsx
index 41165e7..f71eccb 100644
--- a/components/pricing-cards.tsx
+++ b/components/pricing-cards.tsx
@@ -7,7 +7,6 @@ import { Check, Loader2 } from "lucide-react"
 import { useState, useEffect } from "react"
 import { useToast } from "@/hooks/use-toast"
 import { useRouter } from "next/navigation"
-import { useSession } from "next-auth/react"
 
 const plans = [
   {
@@ -54,41 +53,31 @@ const plans = [
 
 export function PricingCards() {
   const [loadingPlan, setLoadingPlan] = useState<string | null>(null)
+  const [isAuthenticated, setIsAuthenticated] = useState(false)
   const [userPlan, setUserPlan] = useState<string | null>(null)
   const { toast} = useToast()
   const router = useRouter()
-  const { data: session, status } = useSession()
-  
-  const isAuthenticated = status === "authenticated"
 
   useEffect(() => {
-    const fetchUserPlan = async () => {
-      if (isAuthenticated) {
-        try {
-          const response = await fetch("/api/auth/me")
-          if (response.ok) {
-            const data = await response.json()
-            setUserPlan(data.plan?.toLowerCase() || "free")
-          }
-        } catch (error) {
-          console.error("Failed to fetch user plan:", error)
+    const checkAuth = async () => {
+      try {
+        const response = await fetch("/api/auth/me")
+        if (response.ok) {
+          const data = await response.json()
+          setIsAuthenticated(true)
+          setUserPlan(data.plan?.toLowerCase() || "free")
+        } else {
+          setIsAuthenticated(false)
         }
+      } catch {
+        setIsAuthenticated(false)
       }
     }
-    fetchUserPlan()
-  }, [isAuthenticated])
+    checkAuth()
+  }, [])
 
   const handleSubscribe = async (planName: string) => {
-    // Check if still loading
-    if (status === "loading") {
-      toast({
-        title: "Loading",
-        description: "Please wait while we verify your session...",
-      })
-      return
-    }
-    
-    if (!isAuthenticated || !session) {
+    if (!isAuthenticated) {
       if (planName === "Free") {
         window.location.href = "/signup"
         return
diff --git a/lib/auth.ts b/lib/auth.ts
index d3eefd1..765c45d 100644
--- a/lib/auth.ts
+++ b/lib/auth.ts
@@ -12,8 +12,17 @@ export const { handlers, auth, signIn, signOut } = NextAuth({
     strategy: "jwt",
     maxAge: 30 * 24 * 60 * 60, // 30 days
   },
-  secret: process.env.AUTH_SECRET || process.env.NEXTAUTH_SECRET,
-  basePath: "/api/auth",
+  cookies: {
+    sessionToken: {
+      name: `${process.env.NODE_ENV === "production" ? "__Secure-" : ""}next-auth.session-token`,
+      options: {
+        httpOnly: true,
+        sameSite: "lax",
+        path: "/",
+        secure: process.env.NODE_ENV === "production",
+      },
+    },
+  },
   pages: {
     signIn: "/login",
     error: "/login",
@@ -80,11 +89,23 @@ export const { handlers, auth, signIn, signOut } = NextAuth({
   ],
   callbacks: {
     async signIn({ user, account, profile }) {
-      // For OAuth providers (Google/Twitter), ALWAYS allow sign in
-      // NextAuth will handle account creation automatically
+      // For OAuth providers (Google/Twitter), ensure email is set
       if (account?.provider === "google" || account?.provider === "twitter") {
-        // Don't do ANY database operations that could fail
-        // Just allow the sign in immediately
+        // Make sure we have an email from the OAuth provider
+        if (!user.email && profile?.email) {
+          // Update user with email from OAuth profile if missing
+          try {
+            await prisma.user.update({
+              where: { id: user.id },
+              data: { 
+                email: profile.email as string,
+                emailVerified: new Date() // OAuth emails are pre-verified
+              }
+            })
+          } catch (error) {
+            console.error("Error updating OAuth user email:", error)
+          }
+        }
         return true
       }
       
@@ -112,24 +133,13 @@ export const { handlers, auth, signIn, signOut } = NextAuth({
       
       return true
     },
-    async jwt({ token, user, account, trigger }) {
-      console.log("[JWT] Called with:", { 
-        hasUser: !!user, 
-        hasToken: !!token,
-        tokenId: token?.id,
-        tokenSub: token?.sub,
-        tokenEmail: token?.email,
-        trigger 
-      })
-      
+    async jwt({ token, user, account }) {
       if (user) {
         token.id = user.id
         token.email = user.email
         token.name = user.name
         token.picture = user.image
         
-        console.log("[JWT] New login - user data:", { id: user.id, email: user.email, name: user.name })
-        
         // Fetch full user data from database
         const dbUser = await prisma.user.findUnique({
           where: { id: user.id },
@@ -159,10 +169,9 @@ export const { handlers, auth, signIn, signOut } = NextAuth({
       }
       
       // On every request, refresh user data from database to keep it current
-      if (token.id || token.sub) {
-        const userId = (token.id as string) || (token.sub as string)
+      if (token.id) {
         const dbUser = await prisma.user.findUnique({
-          where: { id: userId },
+          where: { id: token.id as string },
           select: { 
             name: true,
             email: true,
@@ -176,7 +185,6 @@ export const { handlers, auth, signIn, signOut } = NextAuth({
         })
         
         if (dbUser) {
-          token.id = userId
           token.name = dbUser.name
           token.email = dbUser.email
           token.picture = dbUser.image
@@ -185,42 +193,22 @@ export const { handlers, auth, signIn, signOut } = NextAuth({
           token.subscriptionStatus = dbUser.subscriptionStatus
           token.subscriptionId = dbUser.subscriptionId
           token.subscriptionEndsAt = dbUser.subscriptionEndsAt
-          
-          console.log("[JWT] Refreshed token with DB data:", { id: userId, email: dbUser.email, hasEmail: !!dbUser.email })
-        } else {
-          console.error("[JWT] User not found in database:", userId)
         }
       }
       
       return token
     },
     async session({ session, token }) {
-      console.log("[Session] Token data:", { 
-        hasToken: !!token,
-        tokenId: token?.id,
-        tokenSub: token?.sub,
-        tokenEmail: token?.email,
-        tokenKeys: token ? Object.keys(token) : []
-      })
-      
-      if (token && session) {
-        session.user = {
-          id: (token.id as string) || (token.sub as string),
-          email: (token.email as string) || "",
-          name: (token.name as string) || null,
-          image: (token.picture as string) || null,
-          emailVerified: (token.emailVerified as Date | null) || null,
-          subscribed: (token.subscribed as boolean) || false,
-          subscriptionStatus: (token.subscriptionStatus as string) || "free",
-          subscriptionId: (token.subscriptionId as string) || null,
-          subscriptionEndsAt: (token.subscriptionEndsAt as Date | null) || null,
-        }
-        
-        console.log("[Session] Built session.user:", {
-          id: session.user.id,
-          email: session.user.email,
-          hasEmail: !!session.user.email
-        })
+      if (session.user) {
+        session.user.id = token.id as string
+        session.user.email = token.email as string
+        session.user.name = token.name as string
+        session.user.image = token.picture as string
+        session.user.emailVerified = token.emailVerified as Date | null
+        session.user.subscribed = token.subscribed as boolean
+        session.user.subscriptionStatus = token.subscriptionStatus as string
+        session.user.subscriptionId = token.subscriptionId as string
+        session.user.subscriptionEndsAt = token.subscriptionEndsAt as Date | null
       }
       return session
     },
diff --git a/scripts/fix-missing-emails.mjs b/scripts/fix-missing-emails.mjs
new file mode 100644
index 0000000..e69de29
-- 
2.52.0

